/* This code sample provides a starter kit to implement server side logic for your Teams App in TypeScript,
 * refer to https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference for complete Azure Functions
 * developer guide.
 */

// Import polyfills for fetch required by msgraph-sdk-javascript.
import "isomorphic-fetch";
import { Context, HttpRequest } from "@azure/functions";
import { TeamsFx } from "@microsoft/teamsfx";
import { QnARequestProperties } from "./QnARequestProperties";
import { qnaResponse } from "./QnAResponse";
// import axios from "axios";

import { AxiosStatic } from "axios";
const Axios = require("axios") as AxiosStatic;

interface Response {
  status: number;
  body: { [key: string]: any };
}

type TeamsfxContext = { [key: string]: any };

/**
 * This function handles requests from teamsfx client.
 * The HTTP request should contain an SSO token queried from Teams in the header.
 * Before trigger this function, teamsfx binding would process the SSO token and generate teamsfx configuration.
 *
 * This function initializes the teamsfx SDK with the configuration and calls these APIs:
 * - TeamsFx().setSsoToken() - Construct teamsfx instance with the received SSO token and initialized configuration.
 * - getUserInfo() - Get the user's information from the received SSO token.
 * - createMicrosoftGraphClient() - Get a graph client to access user's Microsoft 365 data.
 *
 * The response contains multiple message blocks constructed into a JSON object, including:
 * - An echo of the request body.
 * - The display name encoded in the SSO token.
 * - Current user's Microsoft 365 profile if the user has consented.
 *
 * @param {Context} context - The Azure Functions context object.
 * @param {HttpRequest} req - The HTTP request.
 * @param {teamsfxContext} TeamsfxContext - The context generated by teamsfx binding.
 * @param {QnARequestProperties} qnarequestProperties - The context generated by teamsfx binding.
 */
export default async function run(
  context: Context,
  req: HttpRequest,
  teamsfxContext: TeamsfxContext,
  qnarequestProperties: QnARequestProperties
): Promise<Response> {
  context.log("HTTP trigger function processed a request.");

  // Initialize response.
  const res: Response = {
    status: 200,
    body: {},
  };

  // Put an echo into response body.
  res.body.receivedHTTPRequestBody = req.body || "";

  // Prepare access token.
  const accessToken: string = teamsfxContext["AccessToken"];
  if (!accessToken) {
    return {
      status: 400,
      body: {
        error: "No access token was found in request header.",
      },
    };
  }

  // Construct teamsfx.
  let teamsfx: TeamsFx;
  try {
    teamsfx = new TeamsFx().setSsoToken(accessToken);
  } catch (e) {
    context.log.error(e);
    return {
      status: 500,
      body: {
        error:
          "Failed to construct TeamsFx using your accessToken. " +
          "Ensure your function app is configured with the right Azure AD App registration.",
      },
    };
  }

  //Setting the Question details
  const qnaReqProps : QnARequestProperties = {
    question:res.body.receivedHTTPRequestBody.question,
    top:res.body.receivedHTTPRequestBody.top,
  }
  // Initiate QnA Maker Response from Language Studio
  const qnaReponse: Promise<any> = await callLanguageStudioEndPoint(context,qnaReqProps);

  res.body = qnaReponse;
  return res;
}

async function callLanguageStudioEndPoint(context: Context, qnarequestProperties: QnARequestProperties): Promise<any> {

    // Initialize response.
    const res: Response = {
      status: 200,
      body: {},
    };
  const qnaEndPoint: string = "https://teams-qnabot.cognitiveservices.azure.com";
  const qnaProjectName: string = "QnaBot";
  const qnaSubsriptionkey: string = "74fad91798c64435b7128a33635afa63";

  const langstudioEndPoint = `${qnaEndPoint}/language/:query-knowledgebases?projectName=${qnaProjectName}&api-version=2021-10-01&deploymentName=production`;
  const langstudioHeader: any = {
    "Ocp-Apim-Subscription-Key": qnaSubsriptionkey,
    "Content-Type": "application/json"
  };
  const langstudioBody: any = {
    "top": qnarequestProperties.top,
    "question": qnarequestProperties.question,
    "includeUnstructuredSources": true,
    "confidenceScoreThreshold": "0.5"
  };

  try {

    const response: any = await Axios.post<qnaResponse>(langstudioEndPoint, langstudioBody, {
      headers: langstudioHeader
    });

    res.body = response.data;

    // let axioRequest: AxiosInstance;
    // const requestOptions: AxiosRequestConfig = {
    //   url: langstudioEndPoint,
    //   headers: langstudioHeader,
    //   data: langstudioBody
    // };

    // const response: any = await axioRequest.post(langstudioEndPoint,langstudioBody,{
    //     headers: langstudioHeader
    //   })
      

    // return new Promise<any>((): void => {
    //   return this.req(requestOptions);
    // })
    // .then((res: any): any => {
    // return qnaResponse = res.data.answers[0].answer;

    // qnaResponse = response.data.answers[0].answer;
  // }, (error: AxiosError): void => {

  //   context.log.error(error);  });
 } catch (err: any) {
    console.log(err);
    context.log.error(err);
    return {
      status: 500,
      body: {
        error:
          "Failed to Get answers for the question",
      },
    };
  }

  return res.body;
}
